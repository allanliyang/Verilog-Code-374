// this file holds opcode for different test cases and instructions

// 1. ldi 	R2, 0x69 						// R2 = 0x69
// 00001 0010 0000 0x69



// 2. ldi 	R2, 2(R2) 						// R2 = 0x6B
// 00001 0010 0010 0x2



// 3. ld 	R1, 0x47 						// R1 = addr(0x47) = 0x94; preload 0x94 at addr 0x47(d71)(actually 72 due to indexing)
// 00000 0001 0000 0x47



// 4. ldi 	R1, 1(R1) 						// R1 = addr(0x47) + 1 = 0x95
// 00001 0001 0001 0x1



// 5. ld 	R0, -7(R1) 						// R0 = addr(0x95 - 7) = 0x34; preload 0x34 at addr 0x8E(d142)(actually 143 due to indexing)
// 00000 0000 0001 -7



// 6. ldi 	R3, 3 							// R3 = 3
// 00001 0011 0000 0x3



// 7. ldi 	R2, 0x43 						// R2 = 0x43
// 00001 0010 0000 0x43



// 8. brmi 	R2, 3 							// continue with the next instruction (will not branch)
// 10011 0010 0011 0x3



// 9. ldi 	R2, 6(R2) 						// R2 = 0x49
// 00001 0010 0010 0x6



// 10. ld 	R7, -2(R2) 						// R7 = addr(0x49 - 2) = addr(0x47) = 0x94; already preloaded initially
// 00000 0111 0010 -2



// 11. nop
// 11010 0000 0000 0000000000000000000



// 12. brpl R7, 2 							// continue with the instruction at “target” (will branch); makes PC = PC+1+2 if R7 is positive
// 10011 0111 0010 0x2



// 13. ldi 	R5, 4(R2) 						// this instruction will not execute
// 00001 0101 0010 0x4



// 14. ldi 	R4, -3(R5) 						// this instruction will not execute
// 00001 0100 0101 -3



// target:
// 15. add 	R2, R2, R3 						// R2 = 0x4C; R2 == 0x49(line 9), R3 == 0x3(line 6)
// 00011 0010 0010 0011 000000000000000



// 16. addi R7, R7, 3 						// R7 = 0x97; R7 == 0x94(line 10)
// 01100 0111 0111 -3



// 17. neg 	R7, R7 							// R7 = 0xFFFFFF69; R7 == 0x97(line 16)
// 10001 0111 0111 0000000000000000000



// 18. not 	R7, R7 							// R7 = 0x96; R7 == 0xFFFFFF69 (line 17)
// 10010 0111 0111 0000000000000000000



// 19. andi R7, R7, 0xF 					// R7 = 6; R7 == 0x96(line 18)
// 01100 0111 0111 0xF



// 20. ror 	R1, R0, R3 						// R1 = 0x80000006; R0 == 0x34(line 5), R3 == 0x3(line 6) VERIFIED
// 01000 0001 0000 0011 000000000000000



// 21. ori 	R7, R1, 9 						// R7 = 0x8000000F; R1 == 0x80000006(line 20) VERIFIED
// 01110 0111 0001 0x9



// 22. shra R1, R7, R3 						// R1 = 0xF0000001; R7 == 0x8000000F(line 21), R3 == 0x3(line 6) VERIFIED
// 00110 0001 0111 0011 000000000000000



// 23. shr 	R2, R2, R3 						// R2 = 9; R2 == 0x49(line 9), R3 == 0x3(line 6) VERIFIED
// 00101 0010 0010 0011 000000000000000 



// 24. st 	0x8E, R2 						   // addr(0x8E)(d142)(actually 143 due to indexing) = 9, new value in memory with address 0x58(should be 0x8E)
// 00010 0010 0000 0x8E



// 25. rol R2, R0, R3        // R2 = 0x1A0, R0 = 0x34 (line 5), R3 = 3 (line 6), VERIFIEDs
// 01001 0010 0000 0011 000000000000000



// 26. or R4, R3, R0         // R4 = 0x37, R3 = 3 (line 6), R0 = 0x34 (line 5), VERIFIEDs
// 01011 0100 0011 0000 000000000000000



// 27. and R1, R2, R0           // R1 = 0x20, R2 = 0x1A0 (line 25), R0 = 0x34 (line 5), VERIFIEDs
// 00011 0001 0010 0000 000000000000000



// 28. st 0x27(R1), R4          // addr(0x27 + 0x20)(d39 + d32)(is actually 72 due to indexing) = 0x37 new value in memory with address 0x47
// 00010 0100 0001 0x27

// 29. sub R0, R2, R4          // R0 = 0x169, R2 = 0x1A0 (line 25), R4 = 0x37 (line 26), VERIFIEDs
00100 0000 0010 0100 000000000000000



// 30. shl R1, R2, R3          // R1 = 0xD00, R2 = 1A0 (line 25), R3 = 3 (line 5), VERIFIEDs
// 00111 0001 0010 0011 000000000000000



// 31. ldi R4, 6               // R4 = 6
00001 0100 0000 0x6



// 32. ldi R5, 0x1B            // R5 = 0x1B
// 00001 0101 0000 0x1B



// 33. mul R5, R4              // HI = 0; LO = 0xA2, R5 = 0x1B (line 32), R4 = 6 (line 31), 0x1B * 6 = 162, VERIFIEDs
01111 0101 0100 000000000000000



// 34. mfhi R7                  // R7 = 0
11000 0111 0000 0000000000000000000



// 35. mflo R6                 // R6 = 0xA2
// 11001 0110 0000 0000000000000000000



// 36. div R5, R4              // HI = 3, LO = 4, R5 = 0x1B (line 32), R4 = 6 (line 31), 0x1B / 6 = 4 Remainder 3, VERIFIEDs
// 10000 0101 0100 0000000000000000000



// 37. ldi R10, 1(R4)           // R10 = R4 + 1 = 7, R4 = 6 (line 31), VERIFIEDs, setting up argument registers for R8, R9, R10, and R11
// 00001 1010 0100 0x1



// 38. ldi R11, -2(R5)          // R11 = R5 + -2 = 0x19, R5 = 0x1B (line 32), VERIFIEDs, setting up argument registers for R8, R9, R10, and R11
00001 1011 0101 -2



// 39. ldi R12, 0(R6)            // R12 = R6 + 0 = 0xA2, R6 = 0xA2 (line 35), VERIFIEDs
// 00001 1100 0110 0000000000000000000



// 40. ldi R13, 3(R7)            // R13 = R7 + 3 = 3, R7 = 0 (line 34), VERIFIEDs
// 00001 1101 0111 0x3



// 41. jal R12                  // R12 = 0xA2 (line 39), address of subroutine subA in R12 - return address in R15
// 10101 1100 0000 0000000000000000000



// 42. halt                     // upon return, the program halts
// 11011 0000 0000 0000000000000000000



// subA: ORG 0xA2 procedure subA is at address 0xA2(d162)(actually 163 due to indexing)
// 163. add R9, R10, R12        // R9 = 0xA9, R10 = 7 (line 37), R12 = 0xA2 (line 39), VERIFIEDs, R9 value gets returned because R8 and R9 are return value registers
// 00011 1001 1010 1100 000000000000000



// 164. sub R8, R11, R13        // R8 = 0x16, R11 = 0x19 (line 38), R13 = 3 (line 40), VERIFIEDs, R8 gets returned 
// 00100 1000 1011 1101 000000000000000



// 165. sub R9, R9, R8          // final R9 = 0x93, initial R9 = 0xA9 (line 43), R8 = 0x16 (line 44), VERIFIEDs
// 00100 1001 1001 1000 000000000000000



// 166. jr R15                 // Return from procedure by jumping to return address at r15
// 10100 1111 0000 0000000000000000000
