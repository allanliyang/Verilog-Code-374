// this file holds opcode for different test cases and instructions


// 1. ldi 	R2, 0x69 						// R2 = 0x69


// 2. ldi 	R2, 2(R2) 						// R2 = 0x6B


// 3. ld 	R1, 0x47 						// R1 = addr(0x47) = 0x94; preload 0x94 at addr 0x47(d71)(actually 72 due to indexing)


// 4. ldi 	R1, 1(R1) 						// R1 = addr(0x47) + 1 = 0x95


// 5. ld 	R0, -7(R1) 						// R0 = addr(0x95 - 7) = 0x34; preload 0x34 at addr 0x8E(d142)(actually 143 due to indexing)


// 6. ldi 	R3, 3 							// R3 = 3


// 7. ldi 	R2, 0x43 						// R2 = 0x43


// 8. brmi 	R2, 3 							// continue with the next instruction (will not branch)


// 9. ldi 	R2, 6(R2) 						// R2 = 0x49


// 10. ld 	R7, -2(R2) 						// R7 = addr(0x49 - 2) = addr(0x47) = 0x94; already preloaded initially


// 11. nop


// 12. brpl R7, 2 							// continue with the instruction at “target” (will branch); makes PC = PC+1+2 if R7 is positive


// 13. ldi 	R5, 4(R2) 						// this instruction will not execute


// 14. ldi 	R4, -3(R5) 						// this instruction will not execute


// target:
// 15. add 	R2, R2, R3 						// R2 = 0x4C; R2 == 0x49(line 9), R3 == 0x3(line 6)


// 16. addi R7, R7, 3 						// R7 = 0x97; R7 == 0x94(line 10)


// 17. neg 	R7, R7 							// R7 = 0xFFFFFF69; R7 == 0x97(line 16)
 

// 18. not 	R7, R7 							// R7 = 0x96; R7 == 0xFFFFFF69 (line 17)


// 19. andi R7, R7, 0xF 					// R7 = 6; R7 == 0x96(line 18)


// 20. ror 	R1, R0, R3 						// R1 = 0x80000006; R0 == 0x34(line 5), R3 == 0x3(line 6) VERIFIED


// 21. ori 	R7, R1, 9 						// R7 = 0x8000000F; R1 == 0x80000006(line 20) VERIFIED


// 22. shra R1, R7, R3 						// R1 = 0xF0000001; R7 == 0x8000000F(line 21), R3 == 0x3(line 6) VERIFIED


// 23. shr 	R2, R2, R3 						// R2 = 9; R2 == 0x49(line 9), R3 == 0x3(line 6) VERIFIED


// 24. st 	0x8E, R2 						   // addr(0x8E)(d142)(actually 143 due to indexing) = 9, new value in memory with address 0x58(should be 0x8E)


// 25. rol R2, R0, R3        // R2 = 0x1A0, R0 = 0x34 (line 5), R3 = 3 (line 6), VERIFIEDs


// 26. or R4, R3, R0         // R4 = 0x37, R3 = 3 (line 6), R0 = 0x34 (line 5), VERIFIEDs


// 27. and R1, R2, R0           // R1 = 0x20, R2 = 0x1A0 (line 25), R0 = 0x34 (line 5), VERIFIEDs


// 28. st 0x27(R1), R4          // addr(0x27 + 0x20)(d39 + d32)(is actually 72 due to indexing) = 0x37 new value in memory with address 0x47


// 29. sub R0, R2, R4          // R0 = 0x169, R2 = 0x1A0 (line 25), R4 = 0x37 (line 26), VERIFIEDs


// 30. shl R1, R2, R3          // R1 = 0xD00, R2 = 1A0 (line 25), R3 = 3 (line 5), VERIFIEDs


// 31. ldi R4, 6               // R4 = 6


// 32. ldi R5, 0x1B            // R5 = 0x1B


// 33. mul R5, R4              // HI = 0; LO = 0xA2, R5 = 0x1B (line 32), R4 = 6 (line 31), 0x1B * 6 = 162, VERIFIEDs


// 34. mfhi R7                  // R7 = 0


// 35. mflo R6                 // R6 = 0xA2


// 36. div R5, R4              // HI = 3, LO = 4, R5 = 0x1B (line 32), R4 = 6 (line 31), 0x1B / 6 = 4 Remainder 3, VERIFIEDs


// 37. ldi R10, 1(R4)           // R10 = R4 + 1 = 7, R4 = 6 (line 31), VERIFIEDs, setting up argument registers for R8, R9, R10, and R11


// 38. ldi R11, -2(R5)          // R11 = R5 + -2 = 0x19, R5 = 0x1B (line 32), VERIFIEDs, setting up argument registers for R8, R9, R10, and R11


// 39. ldi R12, 0(R6)            // R12 = R6 + 0 = 0xA2, R6 = 0xA2 (line 35), VERIFIEDs


// 40. ldi R13, 3(R7)            // R13 = R7 + 3 = 3, R7 = 0 (line 34), VERIFIEDs


// 41. jal R12                  // R12 = 0xA2 (line 39), address of subroutine subA in R12 - return address in R15


// 42. halt                     // upon return, the program halts


// subA: ORG 0xA2 procedure subA is at address 0xA2
// 43. add R9, R10, R12        // R9 = 0xA9, R10 = 7 (line 37), R12 = 0xA2 (line 39), VERIFIEDs, R9 value gets returned because R8 and R9 are return value registers


// 44. sub R8, R11, R13        // R8 = 0x16, R11 = 0x19 (line 38), R13 = 3 (line 40), VERIFIEDs, R8 gets returned 


// 45. sub R9, R9, R8          // final R9 = 0x93, initial R9 = 0xA9 (line 43), R8 = 0x16 (line 44), VERIFIEDs


// 46. jr R15                 // Return from procedure by jumping to return address at r15
